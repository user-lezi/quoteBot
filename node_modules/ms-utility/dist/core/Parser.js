"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const constants_1 = require("../constants");
const join_1 = __importDefault(require("../functions/join"));
class Parser {
    #container = new Map();
    #cache = [];
    #cregex = /()/g;
    #nregex = /[0-9]/;
    #uregex = /()/g;
    constructor(entries = constants_1.DefaultTimeUnits) {
        if (entries) {
            for (let i = 0, len = entries.length; i < len; i++) {
                const d = entries[i];
                this.#container.set(d[0], { ...d[1], letter: d[0] });
                this.#sortContainer();
            }
        }
    }
    #updateCache() {
        this.#cache = Array.from(this.#container.keys());
        this.#cregex = new RegExp(`([0-9]+)(${this.#cache.join('|')})`, `g`);
        this.#uregex = new RegExp(`([0-9]+)( | and )?(${this.#arrayOfUnits().join("|")})`, 'g');
    }
    #arrayOfUnits() {
        const s = new Array();
        let item;
        const values = this.#container.values();
        for (;;) {
            item = values.next();
            if (item.done) {
                break;
            }
            s.push(item.value.letter, item.value.word);
            if (item.value.aliases?.length)
                s.push(...item.value.aliases);
        }
        return s.sort((x, y) => y.length - x.length);
    }
    get uregex() {
        return this.#uregex;
    }
    advancedParseToMS(str) {
        const matches = str.matchAll(this.#uregex);
        let total = 0;
        let item;
        const arr = Array.from(this.#container.values());
        for (;;) {
            item = matches.next();
            if (item.done) {
                break;
            }
            const used = item.value[3];
            const amount = Number(item.value[1]);
            const unit = arr.find(c => c.letter === used || c.word === used || (c.aliases ? c.aliases.some(c => c === used) : false));
            if (!unit) {
                continue;
            }
            total += amount * unit.ms;
        }
        return total;
    }
    unsafeParseToMS(str) {
        const matches = str.matchAll(this.#cregex);
        let item;
        let total = 0;
        for (;;) {
            item = matches.next();
            if (!item.value)
                break;
            const n = Number(item.value[1]);
            const d = item.value[2];
            const unit = this.#container.get(d);
            if (!unit)
                throw new Error(`Invalid unit '${d}'.`);
            total += unit.ms * n;
        }
        return total;
    }
    addTimeUnit(...entries) {
        for (let i = 0, len = entries.length; i < len; i++) {
            const entry = entries[i];
            if (Array.isArray(entry)) {
                entry.map(e => this.#container.set(e.letter, e));
            }
            else {
                this.#container.set(entry.letter, entry);
            }
        }
        this.#sortContainer();
        return this;
    }
    #sortContainer() {
        const cont = Array.from(this.#container.values()).sort((x, y) => y.ms - x.ms);
        this.#container = new Map(cont.map(x => [x.letter, x]));
        this.#updateCache();
    }
    isNumber(char) {
        return this.#nregex.test(char);
    }
    #pluralize(unit, num) {
        return num === 1 ? unit.word : unit.word + 's';
    }
    parseToString(ms, options) {
        const keys = this.#cache;
        const str = [];
        let x = 0;
        for (let i = 0, len = keys.length; i < len; i++) {
            if (options?.limit && x === options.limit)
                break;
            const unit = this.#container.get(keys[i]);
            if (ms >= unit.ms) {
                const many = Math.floor(ms / unit.ms);
                ms -= many * unit.ms;
                str.push(`${many} ${this.#pluralize(unit, many)}`);
                x++;
            }
        }
        if (!str.length)
            return '';
        return (0, join_1.default)(str, options?.limit, options?.separator, options?.and);
    }
    parseToMS(str) {
        let total = 0;
        let numbers = '', captured = '';
        for (let i = 0, len = str.length; i < len; i++) {
            const char = str[i];
            if (this.isNumber(char)) {
                numbers += char;
            }
            else {
                captured += char;
                if (i + 1 !== len && !this.isNumber(str[i + 1])) {
                    continue;
                }
                else {
                    const unit = this.#container.get(captured);
                    if (!unit)
                        throw new Error(`Unit '${captured}' is not valid.`);
                    if (!numbers.length)
                        throw new Error(`There are no numbers for this unit.`);
                    total += Number(numbers) * unit.ms;
                    numbers = '', captured = '';
                }
            }
        }
        return total;
    }
    get container() {
        return this.#container;
    }
}
exports.Parser = Parser;
//# sourceMappingURL=Parser.js.map